package org.cyber.utbot.api.utils.additions.vulnerability

import org.cyber.utbot.api.abstraction.JsonVulnerabilityArgumentsCheck
import org.cyber.utbot.api.abstraction.VulnerabilityCheck
import org.cyber.utbot.api.abstraction.utils.ArgType
import org.cyber.utbot.api.exceptions.CyberException
import org.utbot.engine.*
import soot.*
import soot.Unit
import soot.jimple.Jimple
import soot.jimple.StringConstant
import soot.jimple.internal.JimpleLocal


fun decorateVulnerabilityFunction(
    target: InvocationTarget,
    methodName: String,
    checks: List<VulnerabilityCheck>,
    engine: UtBotSymbolicEngine? = null,
    taintedArgs: MutableSet<Pair<SymbolicValue, Int>>? = null
): Pair<SootMethod, List<String>?> {
    // check if it is already defined
    val cachedMethod = sootClassVulnerabilityChecks.getMethodByNameUnsafe(methodName)
    if (cachedMethod != null) {
        return Pair(cachedMethod, null)
    }

    // helpers
    var objectCounter = 0
    val units = mutableListOf<Unit>()
    val assertUnits = mutableListOf<Unit>()     // at the end of units
    val locals = mutableSetOf<JimpleLocal>()

    // types
    val booleanType = BooleanType.v()
    val paramTypes = target.method.parameterTypes

    // initialize parameter locals
    val parameterLocals = paramTypes.map {
        JimpleLocal("\$q${objectCounter++}", it)
    }
    locals += parameterLocals

    val parameterRefs = paramTypes.mapIndexed { idx, type -> parameterRef(type, idx) }
    val identityStmts = parameterLocals.zip(parameterRefs) { local, ref -> identityStmt(local, ref) }
    units += identityStmts

    var vulnerabilityType = ""
    val methods = mutableListOf<String>()
    // checks
    checks.forEach { vulnerabilityCheck ->
        // assert
        val assertInvoke = assertSootMethod.toStaticInvokeExpr(StringConstant.v(vulnerabilityCheck.description))
        val assertInvokeStmt = assertInvoke.toInvokeStmt()
        assertUnits += assertInvokeStmt
        // assert end

        vulnerabilityCheck.functionIds.forEach { (checkClassName, checkFunctionName) ->
            val checkSootClass = Scene.v().getSootClass(checkClassName)
            vulnerabilityCheck.description?.let { vulnerabilityType = it }

            val checkSootMethod = checkSootClass.getMethodUnsafe(checkFunctionName, paramTypes, booleanType)
            if (checkSootMethod == null) return@forEach
            methods.add(checkSootMethod.name)

            val checkInvoke = if (checkSootMethod.isStatic) {
                checkSootMethod.toStaticInvokeExpr(*parameterLocals.toTypedArray())
            } else {
                val checkNewSootClassExpr = newNewExpr(checkSootClass.type)
                val checkClassInstance = JimpleLocal("\$q${objectCounter++}", checkSootClass.type)
                locals += checkClassInstance
                units += assignStmt(checkClassInstance, checkNewSootClassExpr)

                val checkInitSootMethod = checkSootClass.getMethod("<init>", emptyList())    // TODO (no constructor???)
                val checkInitSootExpr = checkInitSootMethod.toSpecialInvokeExpr(checkClassInstance)
                units += checkInitSootExpr.toInvokeStmt()

                checkSootMethod.toVirtualInvokeExpr(checkClassInstance, *parameterLocals.toTypedArray())
            }

            val checkResult = JimpleLocal("\$q${objectCounter++}", booleanType)
            locals += checkResult
            units += assignStmt(checkResult, checkInvoke)

            val checkCondition = eqExpr(checkResult, int1)
            units += ifStmt(checkCondition, assertInvokeStmt)
        }
    }

    // target   // TODO dynamic invoke
    val targetInvoke = if (target.method.isStatic) {
        target.method.toStaticInvokeExpr(*parameterLocals.toTypedArray())
    } else {
        val targetInstanceType = target.instance!!.type as RefType

        val targetNewSootClassExpr = newNewExpr(targetInstanceType)
        val targetClassInstance = JimpleLocal("\$q${objectCounter++}", targetInstanceType)
        locals += targetClassInstance

        val targetAssignInstanceStmt = assignStmt(targetClassInstance, targetNewSootClassExpr)
        units += targetAssignInstanceStmt

        if (target.method.isConstructor) {
            target.method.toSpecialInvokeExpr(targetClassInstance, *parameterLocals.toTypedArray())
        } else {    // FIXME understand use toInterfaceInvokeExpr or toVirtualInvokeExpr
            try {
                target.method.toVirtualInvokeExpr(targetClassInstance, *parameterLocals.toTypedArray())
            } catch (_: Throwable) {
                target.method.toInterfaceInvokeExpr(targetClassInstance, *parameterLocals.toTypedArray())
            }
        }
    }

    val targetResult = JimpleLocal("\$q${objectCounter++}", target.method.returnType)
    locals += targetResult

    units += assignStmt(targetResult, targetInvoke)

    units += returnStatement(targetResult)

    // update units with assertUnits
    units += assertUnits

    val body = units.toGraphBody()
    body.locals.addAll(locals)

    val sootMethod = createSootMethod(methodName, paramTypes, booleanType, sootClassVulnerabilityChecks, body)

    return Pair(sootMethod, methods)
}

fun createConstraintsFunction(methodName: String, argumentsList: JsonVulnerabilityArgumentsCheck): SootMethod {
    val cachedMethod = sootClassVulnerabilityChecksFunctions.getMethodByNameUnsafe(methodName)
    if (cachedMethod != null) {
        return cachedMethod
    }

    // helpers
    var objectCounter = 0
    val units = mutableListOf<Unit>()
    val locals = mutableSetOf<JimpleLocal>()

    // types
    val booleanType = BooleanType.v()
    val wrapParamTypes = argumentsList.signature.map { ArgType.fromString(it) }
    val paramTypes = wrapParamTypes.map { it.type }

    // initialize parameter locals
    val parameterLocals = paramTypes.map {
        JimpleLocal("\$q${objectCounter++}", it)
    }
    locals += parameterLocals

    val parameterRefs = paramTypes.mapIndexed { idx, type -> parameterRef(type, idx) }
    val identityStmts = parameterLocals.zip(parameterRefs) { local, ref -> identityStmt(local, ref) }
    units += identityStmts


    //
    val constraintsParts = argumentsList.arguments.mapNotNull { args ->
        if (args.size != wrapParamTypes.size) throw CyberException("wrong count arguments: ${args.size} != ${wrapParamTypes.size} ($args, $wrapParamTypes)")
        val valuesWithTypes = args.zip(wrapParamTypes).map { (arg, type) -> if (arg is List<*>) null else type.const(arg) to type }
        val constraints = (parameterLocals.zip(valuesWithTypes).mapNotNull { it.second?.let { valueWithType ->
            val eqInvoke = equals(it.first, valueWithType.first, valueWithType.second)
            val eqResult = JimpleLocal("\$q${objectCounter++}", booleanType)
            locals += eqResult
            units += assignStmt(eqResult, eqInvoke)
            eqResult
        }})
        when(constraints.size) {
            0 -> null
            1 -> constraints.first()
            else -> {
                var and = Jimple.v().newAndExpr(constraints[0], constraints[1])
                var localResultAnd = JimpleLocal("\$q${objectCounter++}", booleanType)
                locals += localResultAnd
                units += assignStmt(localResultAnd, and)
                constraints.drop(2).forEach {
                    and = Jimple.v().newAndExpr(localResultAnd, it)
                    localResultAnd = JimpleLocal("\$q${objectCounter++}", booleanType)
                    locals += localResultAnd
                    units += assignStmt(localResultAnd, and)
                }
                localResultAnd
            }
        }
    }
    val resultLocal = when (constraintsParts.size) {
        0 -> {
            val resultLocal = JimpleLocal("\$q${objectCounter++}", booleanType)
            locals += resultLocal
            units += assignStmt(resultLocal, int0)
            resultLocal
        }

        1 -> constraintsParts.first()
        else -> {
            var or = Jimple.v().newOrExpr(constraintsParts[0], constraintsParts[1])
            var localResultOr = JimpleLocal("\$q${objectCounter++}", booleanType)
            locals += localResultOr
            units += assignStmt(localResultOr, or)
            constraintsParts.drop(2).forEach {
                or = Jimple.v().newOrExpr(localResultOr, it)
                localResultOr = JimpleLocal("\$q${objectCounter++}", booleanType)
                locals += localResultOr
                units += assignStmt(localResultOr, or)
            }
            localResultOr
        }
    }
    units += returnStatement(resultLocal)

    val body = units.toGraphBody()
    body.locals.addAll(locals)

    return createSootMethod(methodName, paramTypes, booleanType, sootClassVulnerabilityChecksFunctions, body)
}
