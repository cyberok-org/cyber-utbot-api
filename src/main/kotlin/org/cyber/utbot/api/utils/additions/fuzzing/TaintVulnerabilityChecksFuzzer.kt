package org.cyber.utbot.api.utils.additions.fuzzing

import VulnerabilityArgumentsCheckWithDescription
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.toList
import mu.KLogger
import mu.KotlinLogging
import org.cyber.utbot.api.utils.*
import org.cyber.utbot.api.utils.additions.constraints.Constraints
import org.cyber.utbot.api.utils.additions.pathSelector.CyberSelector
import org.cyber.utbot.api.utils.annotations.CyberModify
import org.cyber.utbot.api.utils.overrides.fuzzing.cyberMutations
import org.cyber.utbot.api.utils.overrides.fuzzing.cyberRunJavaFuzzing
import org.cyber.utbot.api.utils.overrides.fuzzing.defaultValueProviders
import org.utbot.common.PathUtil.toPath
import org.utbot.common.PathUtil.toURL
import org.utbot.common.filterWhen
import org.utbot.engine.*
import org.utbot.framework.UtSettings
import org.utbot.framework.plugin.api.*
import org.utbot.framework.plugin.api.util.*
import org.utbot.framework.util.graph
import org.utbot.framework.util.isKnownImplicitlyDeclaredMethod
import org.utbot.framework.util.sootMethod
import org.utbot.fuzzer.collectConstantsForFuzzer
import org.utbot.fuzzing.*
import org.utbot.fuzzing.utils.Trie
import org.utbot.instrumentation.ConcreteExecutor
import org.utbot.instrumentation.instrumentation.execution.UtConcreteExecutionResult
import org.utbot.instrumentation.instrumentation.execution.UtExecutionInstrumentation
import soot.tagkit.ParamNamesTag
import java.io.File
import java.lang.Long.min
import java.lang.reflect.Method
import java.net.URLClassLoader
import kotlin.random.Random

typealias Collected = MutableList<Pair<MethodId, MutableList<MutableList<String>>>>

class TaintVulnerabilityChecksFuzzer : VulnerabilityChecksFuzzer {
    private val logger: KLogger = KotlinLogging.logger {}
    override fun generate(
        methodId: MethodId,
        parametersInfo: ParametersInfo?, // not needed ig
        constraints: Constraints,
        description: String,
        methods: List<String>,
        taintedArgs: MutableSet<Pair<SymbolicValue, Int>>,
        methodUnderTest: ExecutableId
    ): VulnerabilityArgumentsCheckWithDescription? {
        val testsCount = 2 // todo(UTBot will probable fail if this number is higher than 3)
        if (CyberSelector.traversedMethods.find { it.contains(methodId.classId.name) } == null) {
            return null
        }
        if (methodId.parameters.size != 2) return null
        return runBlocking {
            val deferredResult: Deferred<VulnerabilityArgumentsCheckWithDescription?> = async(Dispatchers.Default) {
                Configuration.vulnerabilityType = description
                taintedArgs?.let { Configuration.taintedArgs = taintedArgs.map { it.second } }
                updateClassLoader("$UTBOT_DIR/cyber-utbot-exploit-base/build/classes/java/main")
                var collected: Collected = mutableListOf()
                val launchClassName =
                    if (description.contains("file")) "org.cyber.base.Files" to "src/main/java/org/cyber/base/Files"
                    else if (description.contains("command")) "org.cyber.base.Command" to "src/main/java/org/cyber/base/Command"
                    else if (description.contains("SQL")) "org.cyber.base.SQL" to "src/main/java/org/cyber/base/SQL"
                    else "org.cyber.base.Redirect" to "src/main/java/org/cyber/base/Redirect"
                mapOf(launchClassName).toTestUnits().forEach { testUnit ->
                    // maps method to a list of fuzzed arguments for each of its parameters, removers first as afaik it is not needed
                    collected = runInside(testUnit.target, methods)
                }
                if (collected.isEmpty()) return@async null
                val signature =
                    collected[0].first.parameters.map { if (it.name == "java.lang.String") "string" else "unknown" }
                        .toList()
                val fuzzedVals = collected[0].second.map { l -> l.filter { it.length < 20 }.shuffled().toMutableList() }
                    .toMutableList()
                val takenArgs: MutableList<String> = mutableListOf()
                val arguments = (0 until testsCount).map {
                    signature.mapIndexed { i, e ->
                        when (e) {
                            "string" -> {
                                val found = fuzzedVals[i].find { !takenArgs.contains(it) } ?: fuzzedVals[i].random()
                                takenArgs.add(found)
                                found
                            }

                            "int" -> fuzzedVals[i][Random.nextInt(fuzzedVals[i].size)]
                            else -> "unknown"
                        }
                    }
                }
                if (arguments.size > 1) println("gen args ${arguments[0][0]} ${arguments[0][1]} AND ${arguments[1][0]} ${arguments[1][1]}")
                return@async VulnerabilityArgumentsCheckWithDescription(signature, arguments, description)
            }
            return@runBlocking deferredResult.await()
        }
    }

    private lateinit var classLoader: URLClassLoader

    private var classpath: String? = null
    private fun updateClassLoader(classpath: String) {
        if (this.classpath != classpath) {
            this.classpath = classpath
            val urls = classpath
                .split(File.pathSeparator)
                .map { uri ->
                    uri.toPath().toURL()
                }
                .toTypedArray()
            classLoader = URLClassLoader(urls)
        }
    }

    private fun updateClasspath(classpath: String, vulnerabilityCheckBases: List<String>): String { // todo??
        val baseClasspathes = vulnerabilityCheckBases.map {
            "$it${File.separator}$DEFAULT_BUILS_CLASSES_PATH"
        }
        return "$classpath${File.pathSeparator}${baseClasspathes.joinToString(separator = File.pathSeparator)}"
    }

    private val concreteExecutor =
        ConcreteExecutor(
            UtExecutionInstrumentation,
            "$UTBOT_DIR/cyber-utbot-exploit-base/build/classes/java/main",
        ).apply { this.classLoader = utContext.classLoader }

    private fun runInside(
        targetClassFqn: TargetQualifiedName,
        genMethods: List<String> = listOf()
    ): Collected {
        val collected: Collected = mutableListOf()
        try {
            // utContext is used in `targetMethods`, `generate`, `generateTest`, `generateReport`
            withUtContext(UtContext(classLoader)) {
                val classIdUnderTest = ClassId(targetClassFqn)
                val targetMethods = classIdUnderTest.targetMethods()
                    .filterWhen(UtSettings.skipTestGenerationForSyntheticAndImplicitlyDeclaredMethods) {
                        !it.isSynthetic && !it.isKnownImplicitlyDeclaredMethod
                    }
                    .filter {
                        if (genMethods.isEmpty()) true
                        else genMethods.contains(it.name)
                    }
                    .filterNot { it.isAbstract }
                targetMethods.forEach {
                    val l: MutableList<UtResult> = mutableListOf()
                    runBlocking {
                        fuzzing(it).toList(l)
                    }
                    val m = cyberMutations
                    m.removeFirst()
                    collected.add(Pair(it, m))
                }
                if (targetMethods.isEmpty()) {
                    throw Exception("Nothing to process. No methods were provided")
                }
            }
        } catch (e: Exception) {
            logger.error { e.message }
        }
        return collected
    }

    private fun ClassId.targetMethods(): List<MethodId> =
        allMethods.filter { it.classId == this }.toList()

    /**
     * Run fuzzing flow.
     *
     * @param until is used by fuzzer to cancel all tasks if the current time is over this value
     * @param transform provides model values for a method
     */
    @CyberModify("replace original java language fuzzing by cyber fuzzing")
    fun fuzzing(
        methodUnderTest: MethodId,
        until: Long = Long.MAX_VALUE,
        transform: (JavaValueProvider) -> JavaValueProvider = { it }
    ) =
        flow<UtResult> {
            val isFuzzable = methodUnderTest.parameters.all { classId ->
                classId != Method::class.java.id && // causes the instrumented process crash at invocation
                        classId != Class::class.java.id  // causes java.lang.IllegalAccessException: java.lang.Class at sun.misc.Unsafe.allocateInstance(Native Method)
            }
            val hasMethodUnderTestParametersToFuzz = methodUnderTest.parameters.isNotEmpty()
            if (!isFuzzable || !hasMethodUnderTestParametersToFuzz && methodUnderTest.isStatic) {
                // Currently, fuzzer doesn't work with static methods with empty parameters
                return@flow
            }
            val attemptsLimit = UtSettings.fuzzingMaxAttempts
            var attempts = 0
            val graph = methodUnderTest.sootMethod.jimpleBody().graph()
            val names = graph.body.method.tags.filterIsInstance<ParamNamesTag>().firstOrNull()?.names ?: emptyList()
            var testEmittedByFuzzer = 0
            cyberRunJavaFuzzing(
                defaultIdGenerator,
                methodUnderTest,
                collectConstantsForFuzzer(graph),
                names,
                listOf(transform(ValueProvider.of(defaultValueProviders(defaultIdGenerator))))
            ) { thisInstance, descr, values ->
//                println("values: ")
//                values.forEach { println(it.summary) }
                if (thisInstance?.model is UtNullModel) {
                    // We should not try to run concretely any models with null-this.
                    // But fuzzer does generate such values, because it can fail to generate any "good" values.
                    return@cyberRunJavaFuzzing BaseFeedback(Trie.emptyNode(), Control.PASS)
                }

                val diff = until - System.currentTimeMillis() + 1000
                val thresholdMillisForFuzzingOperation = 0 // may be better use 10-20 millis as it might not be possible
                // to concretely execute that values because request to instrumentation process involves
                // 1. serializing/deserializing it with kryo
                // 2. sending over rd
                // 3. concrete execution itself
                // 4. analyzing concrete result
                if (diff <= thresholdMillisForFuzzingOperation || attempts > attemptsLimit) {
                    attempts += 1
                    logger.info { "Fuzzing overtime: $methodUnderTest" }
                    logger.info { "Test created by fuzzer: $testEmittedByFuzzer" }
                    return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.STOP)
                }

                val initialEnvironmentModels = EnvironmentModels(thisInstance?.model, values.map { it.model }, mapOf())

                val concreteExecutionResult: UtConcreteExecutionResult? = try {
                    val timeoutMillis = min(UtSettings.concreteExecutionDefaultTimeoutInInstrumentedProcessMillis, diff)
                    concreteExecutor.executeConcretely(
                        methodUnderTest,
                        initialEnvironmentModels,
                        listOf(),
                        timeoutMillis
                    )
                } catch (e: Throwable) {
                    emit(UtError("Default concrete execution failed", e)); null
                }

                // in case an exception occurred from the concrete execution
                concreteExecutionResult ?: return@cyberRunJavaFuzzing BaseFeedback(
                    result = Trie.emptyNode(),
                    control = Control.PASS
                )

                if (concreteExecutionResult.violatesUtMockAssumption()) {
                    logger.debug { "Generated test case by fuzzer violates the UtMock assumption: $concreteExecutionResult" }
                    return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.PASS)
                }

                val coveredInstructions = concreteExecutionResult.coverage.coveredInstructions
                val trieNode: Trie.Node<Instruction>?
                if (coveredInstructions.isNotEmpty()) {
                    trieNode = descr.tracer.add(coveredInstructions)
                    if (trieNode.count > 10) {
                        if (++attempts >= attemptsLimit) {
                            println("in att")
                            return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.STOP)
                        }
                        return@cyberRunJavaFuzzing BaseFeedback(result = trieNode, control = Control.CONTINUE)
                    }
                } else {
                    logger.error { "Coverage is empty for $methodUnderTest with $values" }
                    val result = concreteExecutionResult.result
                    if (result is UtSandboxFailure) {
                        val stackTraceElements = result.exception.stackTrace.reversed()
//                        if (errorStackTraceTracker.add(stackTraceElements).count > 1) {
//                            return@cyberRunJavaFuzzing BaseFeedback(result = Trie.emptyNode(), control = Control.PASS)
//                        } // todo maybe add
                    }
                }
                testEmittedByFuzzer++
                BaseFeedback(result = Trie.emptyNode(), control = Control.CONTINUE)
            }
        }

}